package com.neilbaner.duke.serialize;

import com.neilbaner.duke.exceptions.DeserializerException;
import com.neilbaner.duke.task.*;

import java.lang.reflect.Type;
import java.util.ArrayList;

/**
 * A collection of static methods to serialize and deserialize
 * Task and TaskList objects.
 * <br/>
 * Output format:
 * A single line of plain text
 * <br/>
 * The delimiter "~~" is used to separate each Task
 * <br/>
 * The delimiter "~" is used to separate each property of a Task
 * <br/>
 * The first token of any Task is a single character T, E, or D
 * representing the type of the task
 * <br/>
 * The next token, for Event or Deadline tasks, is the event time
 * or due date respectively. This is skipped for to-do tasks.
 * <br/>
 * The last two tokens represent the task title, and the "done" status
 * (as Y/N for done/not done) respectively.
 * @author neilbaner
 */
public class Serializer {
    /**
     * Takes in an object of type TaskList and returns a String
     * which can then be written to a file or used otherwise.
     * @param tl TaskList that we want to serialize.
     * @return String containing serialized output
     */
    public static String serializeTaskList(TaskList tl) {
        String serialized = "";
        for (Task t : tl.getAllTasksList()) {
            serialized += serializeTask(t);
            serialized += "~~";
        }
        serialized = serialized.substring(0, serialized.length() - 2);
        return serialized;
    }

    /**
     * Takes a String created by serializeTaskList() and deserializes it
     * into an ArrayList&lt;Task&rt;.
     * @param s The String (eg. from a text file) for the entire task list
     * @return ArrayList&lt;Task&gt; containing all the Task objects represented in the String
     * @throws DeserializerException if there is an error deserializing any task
     */
    public static ArrayList<Task> deserializeTaskList(String s) throws DeserializerException {
        ArrayList<Task> taskList = new ArrayList<Task>();
        String[] tasks = s.split("~~");
        for (int i = 0; i < tasks.length; i++) {
            taskList.add(deserializeTask(tasks[i]));
        }
        return taskList;
    }

    /**
     * Takes a single Task object, and converts it into a String
     * to be written to a file or otherwise stored/transmitted.
     * @param t the Task object to be serialized
     * @return String representing the task
     */
    public static String serializeTask(Task t) {
        Type taskType = t.getClass();
        String serialized = "";
        if (taskType == ToDo.class) {
            serialized += "T~";
        } else if (taskType == Event.class) {
            serialized += "E~";
            serialized += ((Event) t).getEventTime() + "~";
        } else if (taskType == Deadline.class) {
            serialized += "D~";
            serialized += ((Deadline) t).getDueDate() + "~";
        }
        serialized += t.getTitle() + "~";
        serialized += (t.getDone()) ? "Y" : "N";
        return serialized;
    }

    /**
     * Takes a String generated by serializeTask() and attempts to deserialize it
     * into a single Task object (will be of correct subclass type, i.e. ToDo, Deadline, Event)
     * @param s A string, generated by serializeTask() to deserialize
     * @return Task subclass (ToDo, Event, Deadline) as represented by s
     * @throws DeserializerException if there is some error in the string.
     */
    public static Task deserializeTask(String s) throws DeserializerException {
        String parts[];
        Task deserialized;
        parts = s.split("~");
        try {
            if (parts[0].equals("T")) {
                deserialized = new ToDo(parts[1]);
                if (parts[2].equals("Y")) {
                    deserialized.setDone();
                }
            } else if (parts[0].equals("E")) {
                deserialized = new Event(parts[2], parts[1]);
                if (parts[3].equals("Y")) {
                    deserialized.setDone();
                }
            } else if (parts[0].equals("D")) {
                deserialized = new Deadline(parts[2], parts[1]);
                if (parts[3].equals("Y")) {
                    deserialized.setDone();
                }
            } else {
                throw new DeserializerException();
            }
        }catch (ArrayIndexOutOfBoundsException e) {
            throw new DeserializerException();
        }
        return deserialized;
    }
}
